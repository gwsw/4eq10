#!/usr/bin/env perl
use strict;

# Solve puzzles in the 4=10 game.

my $usage = <<_EOF_;
usage: 4eq10 [-n OPS] [-m #][-s][-S] [-t] N1 N2 N3 N4";
             -n Do not use operator (+-*/)
             -m Print no more than # solutions
             -s Same as -m0
             -S Same as -m1
             -t Don't print total
_EOF_

use Getopt::Std;

my $num_var_nodes = 4;
my $num_op_nodes = $num_var_nodes - 1;

my @ops = ( '*', '/', '+', '-' );
my $op_bits = 2; # ln2(@ops)
my $num_opsets = (scalar @ops) ** $num_op_nodes;

my @orders = (
    [0,1,2,3], [0,1,3,2], [0,2,1,3], [0,2,3,1], [0,3,1,2], [0,3,2,1], 
    [1,0,2,3], [1,0,3,2], [1,2,0,3], [1,2,3,0], [1,3,0,2], [1,3,2,0], 
    [2,0,1,3], [2,0,3,1], [2,1,0,3], [2,1,3,0], [2,3,0,1], [2,3,1,0],
    [3,0,1,2], [3,0,2,1], [3,1,0,2], [3,1,2,0], [3,2,0,1], [3,2,1,0],
);
my $num_orders = @orders;

my $num_parensets = 6;

main();
sub main {
    my %opt;
    die $usage if not getopts('m:n:sSt', \%opt);
    my @vars = @ARGV;
    die $usage if not @vars or @vars < 2;
    my $s = new_solver(@vars);
    my %uniq;
    my $solns = 0;
    my $max_print = ($opt{m} ? $opt{m} : $opt{S} ? 1 : $opt{s} ? 0 : 99999999);
    while (solve_next($s, $opt{n})) {
        if (solved($s)) {
            my $prt = print_soln($s);
            if (not $uniq{$prt}) {
                $uniq{$prt} = 1;
                print $prt, "\n" if $solns++ < $max_print;
            }
        }
    }
    print "$solns solutions\n" unless $opt{t};
}

sub new_solver {
    my %solver = (
        'vars'      => \@_,
        'goal'      => 10,
        'order'     => -1,
        'opset'     => 0,
        'parenset'  => 0,
    );
    return \%solver;
}

sub solve_next {
    my ($s, $no_ops) = @_;
    if (++$s->{order} >= $num_orders) {
        $s->{order} = 0;
        my $np = ($no_ops =~ /p/) ? 1 : $num_parensets;
        if (++$s->{parenset} >= $np) {
            $s->{parenset} = 0;
            for (;;) {
                return 0 if ++$s->{opset} >= $num_opsets;
                last unless opset_has($s->{opset}, $no_ops);
            }
        }
    }
    return 1;
}

sub solved {
    my ($s) = @_;
    return solve_total($s) == $s->{goal};
}

sub op_perform {
    my ($s, $opx, $vL, $vR) = @_;
    my $op = op_op($s, $opx);
    return undef if not defined $vL or not defined $vR;
    if ($op == 2) {
        return $vL + $vR;
    } elsif ($op == 3) {
        return $vL - $vR;
    } elsif ($op == 0) {
        return $vL * $vR;
    } elsif ($op == 1) {
        return undef if $vR == 0;
        return $vL / $vR;
    }
    return undef;
}

sub op_var {
    my ($s, $opx) = @_;
    my $order = $orders[$s->{order}];
    return ${$s->{vars}}[$$order[$opx]];
}

sub op_op {
    my ($s, $opx) = @_;
    return opset_op($s->{opset}, $opx);
}

sub opset_op {
    my ($opset, $opx) = @_;
    return ($opset >> ($op_bits * $opx)) & ((1 << $op_bits) -1);
}

sub opset_has {
    my ($opset, $no_ops) = @_;
    for (my $opx = 0; $opx < $num_op_nodes; ++$opx) {
        my $op = $ops[opset_op($opset, $opx)];
        return 1 if index($no_ops, $op) >= 0;
    }
    return 0;
}

sub all_prec {
    my ($opset) = @_;
    my $ap = 0;
    for (my $opx = 0; $opx < $num_op_nodes; ++$opx) {
        my $op = opset_op($opset, $opx);
        $ap <<= 1;
        $ap |= 1 if hi_prec($op);
    }
    return $ap;
}

sub hi_prec {
    my ($op) = @_;
    return ($op <= 1); 
}

sub solve_total {
    my ($s) = @_;
    # THIS DOES NOT SCALE VERY WELL!
    my @solve_algos = (
        # A-B-C-D    A-B-C*D    A-B*C-D    A-B*C*D    A*B-C-D    A*B-C*D    A*B*C-D    A*B*C*D
        'AB0C1D2', 'AB0CD21', 'ABC10D2', 'ABC1D20', 'AB0C1D2', 'AB0CD21', 'AB0C1D2', 'AB0C1D2',

        # (A-B)-C-D  (A-B)-C*D  (A-B)*C-D  (A-B)*C*D  (A*B)-C-D  (A*B)-C*D  (A*B)*C-D  (A*B)*C*D
        'AB0C1D2', 'AB0CD21', 'AB0C1D2', 'AB0C1D2', 'AB0C1D2', 'AB0CD21', 'AB0C1D2', 'AB0C1D2',

        # (A-B-C)-D  (A-B-C)*D  (A-B*C)-D  (A-B*C)*D  (A*B-C)-D  (A*B-C)*D  (A*B*C)-D  (A*B*C)*D
        'AB0C1D1', 'AB0C1D2', 'ABC10D2', 'ABC10D2', 'AB0C1D2', 'AB0C1D2', 'AB0C1D2', 'AB0C1D2',

        # A-(B-C)-D  A-(B-C)*D  A-(B*C)-D  A-(B*C)*D  A*(B-C)-D  A*(B-C)*D  A*(B*C)-D  A*(B*C)*D
        'ABC10D2', 'ABC1D20', 'ABC10D2', 'ABC1D20', 'ABC10D2', 'ABC10D2', 'ABC10D2', 'ABC20D2',

        # A-(B-C-D)  A-(B-C*D)  A-(B*C-D)  A-(B*C*D)  A*(B-C-D)  A*(B-C*D)  A*(B*C-D)  A*(B*C*D)
        'ABC1D20', 'ABCD210', 'ABC1D20', 'ABC1D20', 'ABC1D20', 'ABCD210', 'ABC1D20', 'ABC1D20',

        # A-B-(C-D)  A-B-(C*D)  A-B*(C-D)  A-B*(C*D)  A*B-(C-D)  A*B-(C*D)  A*B*(C-D)  A*B*(C*D)
        'AB0CD21', 'AB0CD21', 'ABCD210', 'ABCD210', 'AB0CD21', 'AB0CD21', 'AB0CD21', 'AB0CD21',
    );

    my @xstack;
    my $sx = ($s->{parenset} * 8) + all_prec($s->{opset});
    my $algo = $solve_algos[$sx];
    foreach my $ch (split //, $algo) {
        if ($ch =~ /[A-D]/) {
            my $opx = ord($ch) - ord('A');
            push @xstack, op_var($s, $opx);
        } elsif ($ch =~ /[0-2]/) {
            my $opx = ord($ch) - ord('0');
            my $v2 = pop @xstack;
            my $v1 = pop @xstack;
            push @xstack, op_perform($s, $opx, $v1, $v2);
        }
    }
    return pop @xstack;
}

sub print_soln {
    my ($s) = @_;
    my $r = '';
    my $p = $s->{parenset};
    for (my $i = 0; $i < 4; ++$i) {
        $r .= "( " if 
            ($i == 0 and ($p == 1 or $p == 2)) or
            ($i == 1 and ($p == 3 or $p == 4)) or
            ($i == 2 and $p == 5);
        $r .= op_var($s,$i);
        $r .= " )" if
            ($i == 1 and $p == 1) or
            ($i == 2 and ($p == 2 or $p == 3)) or
            ($i == 3 and ($p == 4 or $p == 5));
        $r .= " " . $ops[op_op($s,$i)] . " " if $i < 3;
    }
    $r .= " = " . solve_total($s);
    return $r;
}
